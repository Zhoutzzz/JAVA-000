# 结课总结
整个训练营，就如开营课程说的，老师的目的是为我们**构建知识体系，梳理知识脉络，掌握学习方法**，只有构建了知识体系，形成知识网络，在掌握了学习方法之后，学习才能事半功倍，课程中许多模块都会反复提到一些经典通用的编程思想
，侧面证明了高度抽象，总结归纳的重要性，因为很多解决方案的思路都是相同的，知其原理，可以广泛使用。如今结营了，再次感叹，这2000多块钱给自己的投资，真的很赚，感谢老师的悉心教诲，泽哥，睿神，飞哥等助教们不厌其烦的为我们答疑解惑，崔崔，爽哥等教研的认真负责，良苦用心，猫大人尽心尽力带领我们接触开源，走进开源，爱你们。
## JVM

- JVM,是Java程序运行的基石，其屏蔽了操作系统层面的差异，区别于其他的编程语言，通过JVM这一中间层，让Java程序能够做到一次编写，到处运行。整个JVM包含类加载子系统，执行引擎，运行时数据区3个部分，一个Java文件，通过编译器编译生成JVM可以执行的.class文件，通过类加载子系统加载.class文件中的类信息，并将加载内容存入运行时数据区保存，然后通过执行引擎执行程序，而内存回收管理通过垃圾收集器来执行。在第一部分的学习中，了解了各种gc工具的使用方式，学习了如何查看字节码，解释字节码的含义以及出现程序运行缓慢的问题时，一些比较通用的调优思路，比如：
  - 将gc日志dump后进行分析，观察full gc的频率，判断对象的回收速率和分配速率是否合理。
  - 观察老年代的内存使用率，每次回收老年代后可用内存量是否合理，如果每次回收后可用内存基本没有变化，且仍有对象进入老年代，考虑对象的晋升年龄是否过小，对象创建后直接分配进入老年代的阈值是否过小，程序是否有频繁创建大对象的问题。
  - 观察新生代回收情况，根据回收速率和分配速率，判断新生代的大小是否需要调整。

## NIO

- 在NIO部分的学习，进一步学习了经典的5种IO模型，对每一种IO模型的优缺点有了进一步的认识
  - BIO，同步阻塞，效率不高，且每次有一个请求都会创建一个新的IO通道进行对应操作，资源浪费，但是量不大的情况下速度快，实现简单。
  - NIO，同步非阻塞，适用于请求量大的情况，通过轮训的方式来实现非阻塞，相对BIO，它支持更大的吞吐量，实现难度也比BIO要复杂，当并发量太大，轮训带来的上下文切换严重浪费了资源。
  - 多路复用IO，在多路复用IO模型中，最大的特点就是通过一个或者多个固定数量的IO通道来处理请求，多路就是多个IO通道，复用就是一个或多个固定线程处理多个连接，通过一个selector来轮训各通道的状态，不存在上下文切换的问题，不阻塞当前线程，不用对每个请求创建一个IO通道，解决了NIO和BIO存在的问题。
  - 信号驱动IO模型，半异步的IO模型，内核数据准备就绪的时候，会向应用进程发送sigo信号，通知应用程序来读取数据，这里说它是半异步，是因为应用程序，还是会将数据从内核拷贝到工作空间中进行操作。
  - AIO，真正意义上的一步IO模型，当应用程序发起系统调用的时候会立刻返回，而内核将数据拷贝到应用程序的工作空间，通知内核可以直接进行操作。
- 通过对基础IO模型的学习巩固，之后在跟随课程学习netty的时候，就很得心应手，跟着老师梳理的主线进行学习，对netty中的channel，plpeline，handle，context这几个关键内容有了了解，对netty的整体架构有一个全面认识，并且使用netty搭建了一个网关玩具，学以致用，加深理解。

## 并发

- 并发，在学习Java的时候就有接触，但是使用不多，大部分情况都是使用的单线程，而并发又是提升程序运行速度的关键技术，同时保证多线程编程的线程安全也是一个大问题，跟着老师重学并发，对并发有了新的认识，结合并发相关书籍，巩固并发相关知识，重新学习了并发的应用场景，并且在学习过程中结合老师课上的案例和作业练习，加深了对各种并发工具的使用方式的理解，为之后工作中使用并发工具进行编写高性能程序打下了基础，比如：基于wait，notify机制实现的生产者消费者模式，通过join，实现阻塞当前线程，让其他线程执行其他任务，执行完成后当前线程在继续执行，sync锁原理，volitile禁止重排，保证可见性背后的JMM规范。