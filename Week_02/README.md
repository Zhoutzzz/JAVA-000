学习笔记

# 同步/异步，阻塞/非阻塞
假设一个场景，使用socket进行两个进程之间的通信。

* 同步
  * 发出一个*调用*时，在没有得到结果之前，该*调用*就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由*调用者*主动等待/获取这个*调用*的结果。
* 异步
  * *调用*在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在*调用*发出后，*被调用者*通过状态、通知来通知调用者，或通过回调函数处理这个调用。
* 阻塞
  *  阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
* 非阻塞
  * 非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。


同步与异步的区别，在于是否存在主动依赖，即要不要等，是一种行为方式，存在则是同步，不存在则是异步。

阻塞与非阻塞的区别，在于获取结果（信息）的过程中，强调的是这期间的状态，即我获取结果前什么也干不了，挂起了，还是我依然运行，在做别的事情。

## 经典例子
学者去书店买书，去书店说我要买XXX，即发起了一个调用，当学者发起调用之后，存在两种情况，一种一直等到店长给他有没有书的结果，一种说完直接走。

当学者在书店一直等时，就属于同步，当学者不等时，又分两种情况，一种，店长给你送来，这属于异步，因为这不需要主动的去获取书这个结果，另一种有某种方式让你知道书没了，或者有了（回调，主动轮训检查等等），让你来拿，这种严格意义上来说，也是同步，因为就说买书这件事，还是存在一个主动依赖，需要主动获取书这个结果，但这种方式对应的属于信号驱动I/O模型，不严格的说也算是异步。


当学者发起买XXX这个调用时，没有得到有没有书的结果前，学者什么也做不了，处于挂起态，只能在当前调用处硬等结果，即阻塞；如果学者发起买XXX这个调用时，没有得到有没有书的结果前，学者在做别的事情，处于运行态，既是非阻塞（当前调用对应的事件依旧在等结果，但是，没有硬等，能做其他事情）。

其实挂起期间，并不一定会阻塞后面线程执行。

同步非阻塞：即学者在等（同步）有没有书的结果，但是并不是什么也做不了，可以看看其他书，出去找奶茶妹要个微信（非阻塞），过两分钟看看有没有结果，或者等店长电话。


# 5种I/O模型
* BIO(同步阻塞I/O)
  * 就是那种recv, read，一直等，等到有了数据才返回，常规socket编程。
* IO复用(同步阻塞I/O)
  * IO复用其实也是阻塞的，不过可以用来等很多描述符，比起阻塞有了进步，可以算有点异步了，但需要阻塞着检查是否可读。对同一个描述符的IO操作也是有序的。
* NIO(同步非阻塞I/O)
  * 非阻塞IO就是立即返回，设置描述符为非阻塞，但是要进程自己一直检查是否可读
* 信号驱动IO(同步非阻塞I/O)
  * 信号驱动采用信号机制等待，有了更多的进步，不用监视描述符了，而且不用阻塞着等待数据到来，被动等待信号通知，由信号处理程序处理。但对同一个描述符的IO操作还是有序的。
* AIO(异步非阻塞I/O)
  * 异步IO，发送IO请求后，不用等了，也不再需要发送IO请求获取结果了。等到通知后，其实是系统帮你把数据读取好了的，你等到的通知也不再是要求你去读写IO了，而是告诉你IO请求过程已经结束了。你要做的就是可以处理数据了。且同一个描述符上可能同时存在很多请求。(对应上面那个买书例子中，就是送书到我家，我直接看书就行了，不需要再去跑一趟了)。

