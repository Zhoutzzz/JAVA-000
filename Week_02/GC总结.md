
# 对于Parallel、CMS、G1 GC 的总结

对Parallen, CMS, G1在不同堆内存下的工作情况进行观察分析。发现再堆比较小的情况下，三者回收效率差别不大，但在内存分配方面，并行GC比较特殊，再默认配置情况下，其新生代并不总是8：1：1的分配比例，会根据实际使用情况进行动态调整，极端情况下可能为1：1：1，JVM在运行时，新生代的使用空间会根据具体运行情况进行增减，但是在一开始就会分配好各个区最大内存，在此基础上进行调整，见过极端情况下eden和s0,s1的最大空间都差不多，也就是1：1：1的比例。有时候又会以默认8：1：1的比例进行分配

## 关于ParallelGC

    Heap
    PSYoungGen      total 116736K, used 3135K [0x00000000f5580000, 0x0000000100000000, 0x0000000100000000)
    eden space 58880K, 5% used [0x00000000f5580000,0x00000000f588fff8,0x00000000f8f00000)
    from space 57856K, 0% used [0x00000000f8f00000,0x00000000f8f00000,0x00000000fc780000)
    to   space 57344K, 0% used [0x00000000fc800000,0x00000000fc800000,0x0000000100000000)
    ParOldGen       total 349696K, used 342285K [0x00000000e0000000, 0x00000000f5580000, 0x00000000f5580000)
    object space 349696K, 97% used [0x00000000e0000000,0x00000000f4e43668,0x00000000f5580000)
    Metaspace       used 2697K, capacity 4486K, committed 4864K, reserved 1056768K
    class space    used 290K, capacity 386K, committed 512K, reserved 1048576K
在512m空间下，发现三个区域的内存都差不多，结合官方文档对应PS收集器的内存布局介绍推断，此时只有一个s区

    Heap
    PSYoungGen      total 58368K, used 29696K [0x00000000fab00000, 0x0000000100000000, 0x0000000100000000)
    eden space 29696K, 100% used [0x00000000fab00000,0x00000000fc800000,0x00000000fc800000)
    from space 28672K, 0% used [0x00000000fe400000,0x00000000fe400000,0x0000000100000000)
    to   space 28672K, 0% used [0x00000000fc800000,0x00000000fc800000,0x00000000fe400000)
    ParOldGen       total 175104K, used 174964K [0x00000000f0000000, 0x00000000fab00000, 0x00000000fab00000)
    object space 175104K, 99% used [0x00000000f0000000,0x00000000faadd2c0,0x00000000fab00000)
    Metaspace       used 2722K, capacity 4486K, committed 4864K, reserved 1056768K
    class space    used 293K, capacity 386K, committed 512K, reserved 1048576K
再看256m的情况，发现总共新生代只被用了一半空间，eden满了，两个s区为0，且这三个区内存分配也都差不多，推断也是只有一个S区，这就能与官方文档的介绍对应上。

* [关于Java8中Parallel Collections的介绍](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/parallel.html#parallel_collector)

PS收集器特点在于，它会先考虑最大停顿时间，再考虑吞吐量，再考虑内存占用

## 关于CMS
* 初始标记 （STW）

  简单来说，就是扫描根节点对象和跨代引用的对象。
* 并发标记

  因为是并发运行的，在运行期间会发生新生代的对象晋升到老年代、或者是直接在老年代分配对象、或者更新老年代对象的引用关系等等，对于这些对象，都是需要进行重新标记的，否则有些对象就会被遗漏，发生漏标的情况。为了提高重新标记的效率，该阶段会把上述对象所在的Card标识为Dirty，后续只需扫描这些Dirty Card的对象，避免扫描整个老年代； 
  并发标记阶段只负责将引用发生改变的Card标记为Dirty状态，不负责处理

* 并发预清理

  前一个阶段已经说明，不能标记出老年代全部的存活对象，是因为标记的同时应用程序会改变一些对象引用，这个阶段就是用来处理前一个阶段因为引用关系改变导致没有标记到的存活对象的，它会扫描所有标记为Direty的Card，更新标记
* 并发可终止预清理

  这其实不是必须的，因为做的事情跟上一步是一样的，可终止表示可以根据运行时间，运行次数，或其他的条件终止这个阶段，这个阶段开始过程中，可能会触发一些YGC，这些YGC为了后面最终标记做铺垫，尽量保证新生代是干净的，可以减小后面的扫描时间。
* 最终标记 (STW)

  最后再从根节点扫描一遍对象，标记它们，前面的并发标记，预清理，可终止预清理，就是为了减少这次标记的暂停时间。可以用-XX:+CMSParallelRemarkEnabled开启并行标记
* 并发清理

  对上面过程中未被标记的对象，跟用户线程一起并发进行清理工作。
* 并发重置

  对CMS数据结构进行重置，为下一次收集做准备。

-XX:+CMSScavengeBeforeRemark
在进行标记之前，进行一次YGC，CMS执行期间如果标记时间比较久，可以使用这个参数进行优化。

-XX:CMSFullGCsBeforeCompaction=n
在上一次CMS并发GC执行过后，到底还要再执行多少次full GC才会做压缩。默认是0，压缩期间会导致整个回收时间增长，需要根据具体情况进行取舍，选择一个合适的值，最好做到降低压缩频率减少暂停时间的同时碎片化问题带来的影响也是可控的。

-XX:CMSInitiatingOccupancyFraction=70
设定CMS在对内存占用率达到70%的时候开始GC。太大可能会导致concurrent mode failure，太小，会造成GC频繁，空闲空间过多，也需要进行具体情况设置。


## 关于G1
g1收集是基于reigon，分析各个reigon中回收大小，以此构成回收集，收集时选择回收效果最好的回收集进行回收。

* 疏散暂停：Full Young （STW）
在应用程序生命周期的开始，G1在尚未执行的并发阶段没有任何其他信息，因此它最初以Full Young的模式运行。当Young Generation填满时，应用程序线程将停止，并将Young区域内的实时数据复制到Survivor区域，或任何由此成为Survivor的空闲区域。工作方式与之前见过的其他年轻代收集器几乎相同，列如ParNew。

* 并发标记
  
  其实，G1并发标记与CMS大体相似，只是在G1中，使用了RememberSet（记忆集，本质上是一个Hash Table,Key为别的reigon起始位置，Value为卡表索引号组成的集合）和STAB（原始快照）来辅助G1进行并发标记过程中确定回收对象。G1的记忆集与CMS的卡表正好相反，CMS中的卡表记录的是该对象所引用的对象（我用了谁），G1的记忆集除此之外还记录了引用了该对象的其他对象（谁用了我）
  * 阶段1：初始标记。此阶段标记了可从GC根直接访问的所有对象。在CMS中，它会触发STW，但在G1中，其会借用YGC的STW，因此其开销很小。

  * 阶段2：根区域扫描。这个阶段标记了所有可从GC Root到达的活动对象，即那些不是空的并且可能最终不得不在标记周期的中间收集的活动对象。由于在并发标记的中间移动东西会引起麻烦，因此必须在下一个疏散暂停开始之前完成此阶段。如果必须更早开始，它将请求根区域扫描的早期中止，然后等待其完成。在当前的实现中，根区域是Servivors区域：它们是年轻代的一部分，肯定会在下一次撤离暂停中收集。

  * 阶段3:并发标记。此阶段与CMS非常相似：它只是遍历对象图并在特殊的位图中标记访问的对象。为确保满足原始快照的语义，G1 GC要求应用程序线程对对象图进行的所有并发更新都应保留先前的已知标记信息（也就是要重新处理下STAB的记录）。

  * 阶段4:重新标记。就像先前在CMS中看到的那样，这个阶段也是会发生STW。对于G1，它短暂地停止了应用程序线程以停止并发更新日志的流入，并处理了剩余的少量日志，并标记了在启动并发标记周期时仍处于活动状态的所有未标记对象。此阶段还执行一些其他的清理操作，例如类卸载。

  * 阶段5:清理。此最后阶段为即将到来的疏散阶段做准备，对堆区域中的所有活动对象进行计数，并根据预期的GC效率对这些区域进行排序。它还执行所有维护工作，以维护并发标记的下一次迭代的内部状态，这个阶段也发生STW。

  G1在初始标记，最终标记，清理回收阶段，都会出现STW，而CMS在初始标记和最终标记出现STW，看似比G1的要少，但是G1速度比CMS快，得益于基于reigon的设计，原始快照，记忆集这些思想的运用，相对的，G1在运行过程中，使用的内存空间其实也比CMS的多，一般来说，G1可能要花费大约相当于整个堆容量10%~20%的内存空间来保证收集器工作，粗略来看，可以看作是空间换时间的想法。
* 参考文章

  深入理解Java虚拟机（第三版）

  [美团-G1 GC的关键技术](https://tech.meituan.com/2016/09/23/g1.html)

  [G1 GC Algorithms: Implementations](https://plumbr.io/handbook/garbage-collection-algorithms-implementations#g1)